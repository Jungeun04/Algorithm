[회전 초밥](https://www.acmicpc.net/problem/15961)

이 문제는 슬라이딩 윈도우와 해시맵(또는 배열을 이용한 카운팅)을 사용하여 해결할 수 있습니다. 주어진 벨트에서 연속된 `k`개의 초밥을 선택했을 때, 먹을 수 있는 서로 다른 종류의 초밥 수의 최대값을 찾는 문제입니다. 여기에 쿠폰으로 받은 초밥이 더해지면서 종류의 수가 하나 늘어날 수 있습니다.

### 접근 방법

1. **초밥 종류 카운팅**: 선택한 연속된 `k`개의 초밥에 대해 각 종류별로 몇 개씩 있는지 카운팅합니다.
2. **슬라이딩 윈도우**: 벨트 전체를 대상으로 길이 `k`의 윈도우를 슬라이딩하면서, 윈도우 내에 포함된 서로 다른 초밥 종류의 수를 계산합니다.
3. **쿠폰 초밥 추가**: 현재 윈도우에서 선택할 수 있는 초밥 종류에 쿠폰으로 주어진 초밥이 포함되어 있지 않다면, 초밥 종류 수를 하나 늘립니다.
4. **최대 초밥 종류 수 갱신**: 각 슬라이딩 윈도우에서 계산된 초밥 종류 수를 기반으로 최대값을 갱신합니다.

### 구현 예시

```python
N, d, k, c = map(int, input().split())  # 접시 수, 초밥 종류 수, 연속 접시 수, 쿠폰 번호
sushi = [int(input()) for _ in range(N)]  # 회전 초밥 벨트 상태

# 초밥 종류 카운팅을 위한 해시맵 초기화
count = {c: 1}  # 쿠폰으로 받은 초밥은 항상 포함
for i in range(k):  # 첫 번째 윈도우 초기화
    count[sushi[i]] = count.get(sushi[i], 0) + 1

max_types = len(count)  # 최대 초밥 종류 수

# 슬라이딩 윈도우로 최대 초밥 종류 수 갱신
for i in range(1, N):
    # 윈도우에서 제거될 초밥 처리
    remove_sushi = sushi[i-1]
    count[remove_sushi] -= 1
    if count[remove_sushi] == 0:
        del count[remove_sushi]
    
    # 윈도우에 추가될 초밥 처리
    add_sushi = sushi[(i+k-1) % N]  # 벨트는 원형이므로 모듈로 연산 사용
    count[add_sushi] = count.get(add_sushi, 0) + 1
    
    # 최대 초밥 종류 수 갱신
    max_types = max(max_types, len(count))

print(max_types)
```

이 코드는 입력받은 회전 초밥 벨트 상태에서 연속된 `k`개의 초밥을 선택했을 때 먹을 수 있는 서로 다른 종류의 초밥 수의 최대값을 찾아 출력합니다. 초기 윈도우 설정 후, 윈도우를 한 칸씩 이동하면서 윈도우에 포함된 초밥 종류의 수를 계산하고, 이때 쿠폰으로 받은 초밥 종류도 고려합니다.